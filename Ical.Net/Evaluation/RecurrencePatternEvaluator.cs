//
// Copyright ical.net project maintainers and contributors.
// Licensed under the MIT license.
//

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Ical.Net.DataTypes;
using NodaTime;
using NodaTime.Calendars;
using NodaTime.Extensions;
using NodaTime.TimeZones;

namespace Ical.Net.Evaluation;

public class RecurrencePatternEvaluator : Evaluator
{
    protected RecurrencePattern Pattern { get; set; }

    public RecurrencePatternEvaluator(RecurrencePattern pattern)
    {
        Pattern = pattern;
    }

    private RecurrencePattern ProcessRecurrencePattern(CalDateTime referenceDate)
    {
        var r = new RecurrencePattern();
        r.CopyFrom(Pattern);

        if (referenceDate.HasTime)
        {
            if (r.Frequency > FrequencyType.Secondly && r.BySecond.Count == 0 && referenceDate.HasTime
                /* NOTE: Fixes a bug where all-day events have BySecond/ByMinute/ByHour added incorrectly */)
            {
                r.BySecond.Add(referenceDate.Second);
            }
            if (r.Frequency > FrequencyType.Minutely && r.ByMinute.Count == 0 && referenceDate.HasTime
                /* NOTE: Fixes a bug where all-day events have BySecond/ByMinute/ByHour added incorrectly */)
            {
                r.ByMinute.Add(referenceDate.Minute);
            }
            if (r.Frequency > FrequencyType.Hourly && r.ByHour.Count == 0 && referenceDate.HasTime
                /* NOTE: Fixes a bug where all-day events have BySecond/ByMinute/ByHour added incorrectly */)
            {
                r.ByHour.Add(referenceDate.Hour);
            }
        }
        else
        {
            // The BYSECOND, BYMINUTE and BYHOUR rule parts MUST NOT be specified
            // when the associated "DTSTART" property has a DATE value type.
            // These rule parts MUST be ignored in RECUR value that violate the
            // above requirement(e.g., generated by applications that pre - date
            // this revision of iCalendar).
            r.BySecond.Clear();
            r.BySecond.Add(0);
            r.ByMinute.Clear();
            r.ByMinute.Add(0);
            r.ByHour.Clear();
            r.ByHour.Add(0);
        }

        // If BYDAY, BYYEARDAY, or BYWEEKNO is specified, then
        // we don't default BYDAY, BYMONTH or BYMONTHDAY
        if (r.ByDay.Count == 0)
        {
            // If the frequency is weekly, use the original date's day of week.
            // NOTE: fixes WeeklyCount1() and WeeklyUntil1() handling
            // If BYWEEKNO is specified and BYMONTHDAY/BYYEARDAY is not specified,
            // then let's add BYDAY to BYWEEKNO.
            // NOTE: fixes YearlyByWeekNoX() handling
            if (r.Frequency == FrequencyType.Weekly || (r.ByWeekNo.Count > 0 && r.ByMonthDay.Count == 0 && r.ByYearDay.Count == 0))
            {
                r.ByDay.Add(new WeekDay(referenceDate.DayOfWeek));
            }

            // If BYMONTHDAY is not specified,
            // default to the current day of month.
            // NOTE: fixes YearlyByMonth1() handling, added BYYEARDAY exclusion
            // to fix YearlyCountByYearDay1() handling
            if (r.Frequency > FrequencyType.Weekly && r.ByWeekNo.Count == 0 && r.ByYearDay.Count == 0 && r.ByMonthDay.Count == 0)
            {
                r.ByMonthDay.Add(referenceDate.Day);
            }

            // If BYMONTH is not specified, default to
            // the current month.
            // NOTE: fixes YearlyCountByYearDay1() handling
            if (r.Frequency > FrequencyType.Monthly && r.ByWeekNo.Count == 0 && r.ByYearDay.Count == 0 && r.ByMonth.Count == 0)
            {
                r.ByMonth.Add(referenceDate.Month);
            }
        }

        // Pre-order those BY values that don't allow for negative values. Those with negative values can only
        // be ordered once the individual position is known.
        if (r.BySecond.Count > 0) r.BySecond = r.BySecond.OrderBy(x => x).ToList();
        if (r.ByMinute.Count > 0) r.ByMinute = r.ByMinute.OrderBy(x => x).ToList();
        if (r.ByHour.Count > 0) r.ByHour = r.ByHour.OrderBy(x => x).ToList();
        if (r.ByMonth.Count > 0) r.ByMonth = r.ByMonth.OrderBy(x => x).ToList();

        return r;
    }

    /// <summary>
    /// Returns a list of start dates in the specified period represented by this recurrence pattern.
    /// This method includes a base date argument, which indicates the start of the first occurrence of this recurrence.
    /// The base date is used to inject default values to return a set of dates in the correct format.
    /// For example, if the search start date (start) is Wed, Mar 23, 12:19PM, but the recurrence is Mon - Fri, 9:00AM - 5:00PM,
    /// the start dates returned should all be at 9:00AM, and not 12:19PM.
    /// </summary>
    private IEnumerable<ZonedDateTime> GetDates(CalDateTime seed, DateTimeZone timeZone, Instant? periodStart, RecurrencePattern pattern,
         EvaluationOptions? options)
    {
        // Floating values should be evaluated in the given time zone.
        // Other values should be evaluated in their time zone and then
        // converted to the given time zone.
        var originalDate = seed.AsZonedOrDefault(timeZone);

        var seedCopy = originalDate;

        var periodStartDt = periodStart?.InZone(originalDate.Zone);

        var weekYearRule = GetWeekYearRule(pattern);

        if ((pattern.Frequency == FrequencyType.Yearly) && (pattern.ByWeekNo.Count != 0))
        {
            // Dates in the first or last week of the year could belong weeks that belong to
            // the prev/next year, in which case we must adjust that year. This is necessary
            // to get the intervals right.
            IncrementDate(ref seedCopy, pattern, weekYearRule.GetWeekYear(seedCopy.Date) - seedCopy.Year);
        }

        // optimize the start time for selecting candidates
        // (only applicable where a COUNT is not specified)
        if (pattern.Count is null && periodStartDt is not null)
        {
            var incremented = seedCopy;
            while (incremented.ToInstant() < periodStartDt.Value.ToInstant())
            {
                seedCopy = incremented;
                IncrementDate(ref incremented, pattern, pattern.Interval);
            }
        }
        else
        {
            if (pattern.Count < 1)
                throw new Exception("Count must be greater than 0");
        }

        // Do the enumeration in a separate method, as it is a generator method that is
        // only executed after enumeration started. In order to do most validation upfront,
        // do as many steps outside the generator as possible.
        return EnumerateDates(originalDate, seedCopy, pattern, options)
            .Select(x => x.WithZone(timeZone));
    }

    private IEnumerable<ZonedDateTime> EnumerateDates(ZonedDateTime originalDate, ZonedDateTime intervalRefTime, RecurrencePattern pattern, EvaluationOptions? options)
    {
        var expandBehavior = RecurrenceUtil.GetExpandBehaviorList(pattern);

        var searchEndDate = GetSearchEndDate(pattern, originalDate.Zone);

        var noCandidateIncrementCount = 0;

        var dateCount = 0;

        while (true)
        {

            if (searchEndDate != null && searchEndDate.Value.ToInstant() < GetIntervalLowerLimit(intervalRefTime, pattern).ToInstant())
                break;


            var candidates = GetCandidates(originalDate.Zone, intervalRefTime, pattern, expandBehavior);

            foreach (var candidate in candidates.Where(t => t.ToInstant() >= originalDate.ToInstant()))
            {
                noCandidateIncrementCount = 0;

                // candidates MAY occur before periodStart
                // For example, FREQ=YEARLY;BYWEEKNO=1 could return dates
                // from the previous year.

                yield return candidate;

                if (++dateCount >= pattern.Count)
                    yield break;
            }

            if (noCandidateIncrementCount > options?.MaxUnmatchedIncrementsLimit)
                throw new EvaluationLimitExceededException();

            noCandidateIncrementCount++;

            IncrementDate(ref intervalRefTime, pattern, pattern.Interval);
        }
    }

    private static ZonedDateTime? GetSearchEndDate(RecurrencePattern pattern, DateTimeZone timeZone)
    {
        // This value is only used for performance reasons to stop incrementing after
        // until is passed, even if no recurrences are being found.
        // As a safe heuristic we add 1d to the UNTIL value to cover any time shift and DST changes.
        // It's just important that we don't miss any recurrences, not that we stop exactly at UNTIL.
        // Precise UNTIL handling is done outside this method after TZ conversion.
        var coarseUntil = pattern.Until?.ToZonedDateTime(timeZone)
            .LocalDateTime
            .PlusDays(1)
            .InZoneLeniently(timeZone);

        return coarseUntil;
    }

    /// <summary>
    /// Find the lowest possible date/time for a recurrence in the given interval.
    /// </summary>
    /// <remarks>
    /// Usually intervalRefTime is either at DTSTART or later at the start of the interval.
    /// However, for YEARLY recurrences with BYWEEKNO=1 there could be recurrences before
    /// Jan 1st, so we need to adjust the intervalRefTime to the start of the week.
    /// </remarks>
    private static ZonedDateTime GetIntervalLowerLimit(ZonedDateTime intervalRefTime, RecurrencePattern pattern)
    {
        var intervalLowerLimit = intervalRefTime;
        if ((pattern.Frequency == FrequencyType.Yearly) && (pattern.ByWeekNo.Count != 0))
            intervalLowerLimit = GetFirstDayOfWeekDate(intervalRefTime.LocalDateTime, pattern.FirstDayOfWeek)
                .InZoneLeniently(intervalRefTime.Zone);
        return intervalLowerLimit;
    }

    private struct ExpandContext
    {
        /// <summary>
        /// Indicates whether the dates have been fully expanded. If true, subsequent parts should only limit, not expand.
        /// </summary>
        /// <remarks>
        /// This makes a difference in case of BYWEEKNO, which might span months and years. After it was applied (BYWEEKNO would
        /// always expand), the subsequent parts mustn't expand.
        /// </remarks>
        public bool DatesFullyExpanded { get; set; }
    }

    /// <summary>
    /// Returns a list of possible dates generated from the applicable BY* rules, using the specified date as a seed.
    /// </summary>
    /// <param name="date">The seed date.</param>
    /// <param name="pattern"></param>
    /// <param name="expandBehaviors"></param>
    /// <returns>A list of possible dates.</returns>
    private IEnumerable<ZonedDateTime> GetCandidates(DateTimeZone timeZone, ZonedDateTime date, RecurrencePattern pattern, bool?[] expandBehaviors)
    {
        var expandContext = new ExpandContext() { DatesFullyExpanded = false };

        IEnumerable<ZonedDateTime> dates = [ date ];
        dates = GetMonthVariants(dates, pattern, expandBehaviors[0]);
        dates = GetWeekNoVariants(dates, pattern, expandBehaviors[1], ref expandContext);
        dates = GetYearDayVariants(dates, pattern, expandBehaviors[2], ref expandContext);
        dates = GetMonthDayVariants(dates, pattern, expandBehaviors[3], ref expandContext);
        dates = GetDayVariants(dates, pattern, expandBehaviors[4], ref expandContext);

        dates = GetHourVariants(dates, pattern, expandBehaviors[5]);
        dates = GetMinuteVariants(dates, pattern, expandBehaviors[6]);
        dates = GetSecondVariants(dates, pattern, expandBehaviors[7]);
        dates = ApplySetPosRules(dates, pattern);

        return dates;
    }

    /// <summary>
    /// Applies BYSETPOS rules to <paramref name="dates"/>. Valid positions are from 1 to the size of the date list. Invalid
    /// positions are ignored.
    /// </summary>
    /// <param name="dates">The list of dates to which the BYSETPOS rules will be applied.</param>
    /// <param name="pattern"></param>
    private static IEnumerable<T> ApplySetPosRules<T>(IEnumerable<T> dates, RecurrencePattern pattern)
    {
        // return if no SETPOS rules specified..
        if (pattern.BySetPosition.Count == 0)
            return dates;

        HashSet<int> bySetPos;

        if (pattern.BySetPosition.Any(p => p < 0)) {
            var tmp = dates.ToList();
            var count = tmp.Count;
            dates = tmp;
            bySetPos = [.. pattern.BySetPosition.Select(p => (p < 0) ? count + p + 1 : p)];
        } else {
            bySetPos = [.. pattern.BySetPosition];
        }

        return dates.Where((d, i) => bySetPos.Contains(i + 1));
    }

    /// <summary>
    /// Applies BYMONTH rules specified in this Recur instance to the specified date list. 
    /// If no BYMONTH rules are specified, the date list is returned unmodified.
    /// </summary>
    /// <param name="dates">The list of dates to which the BYMONTH rules will be applied.</param>
    /// <param name="pattern"></param>
    /// <param name="expand"></param>
    /// <returns>The modified list of dates after applying the BYMONTH rules.</returns>
    private static IEnumerable<ZonedDateTime> GetMonthVariants(IEnumerable<ZonedDateTime> dates, RecurrencePattern pattern, bool? expand)
    {
        if (expand == null || pattern.ByMonth.Count == 0)
            return dates;

        if (expand.Value)
        {
            // Expand behavior
            return dates.SelectMany(d => pattern.ByMonth
                .Select(month => d.LocalDateTime.PlusMonths(month - d.Month).InZoneLeniently(d.Zone)));
        }

        // Limit behavior
        if (pattern.Frequency == FrequencyType.Weekly)
        {
            // The dates here represent weeks, with each date being the
            // start of a week except for the initial reference date.
            // Return weeks that have any day within BYMONTH.
            return dates.Where(date => pattern.ByMonth.Contains(date.Month)
                || pattern.ByMonth.Contains(date.LocalDateTime.PlusDays(6).InZoneLeniently(date.Zone).Month));
        }
        else
        {
            return dates.Where(date => pattern.ByMonth.Contains(date.Month));
        }
    }

    /// <summary>
    /// Applies BYWEEKNO rules specified in this Recur instance to the specified date list. 
    /// If no BYWEEKNO rules are specified, the date list is returned unmodified.
    /// </summary>
    /// <param name="dates">The list of dates to which the BYWEEKNO rules will be applied.</param>
    /// <returns>The modified list of dates after applying the BYWEEKNO rules.</returns>
    private static IEnumerable<ZonedDateTime> GetWeekNoVariants(IEnumerable<ZonedDateTime> dates, RecurrencePattern pattern, bool? expand, ref ExpandContext expandContext)
    {
        if (expand == null || pattern.ByWeekNo.Count == 0)
            return dates;

        Debug.Assert(expand.Value);

        // Expand behavior
        var weekNoDates = GetWeekNoVariantsExpanded(dates, pattern);

        // subsequent parts should only limit, not expand
        expandContext.DatesFullyExpanded = true;

        // Apply BYMONTH limit behavior, as we might have expanded over month/year boundaries
        // in this method and BYMONTH has already been applied before, so wouldn't be again.
        return GetMonthVariants(weekNoDates, pattern, expand: false);
    }

    private static IWeekYearRule GetWeekYearRule(RecurrencePattern pattern) =>
        WeekYearRules.ForMinDaysInFirstWeek(4, pattern.FirstDayOfWeek.ToIsoDayOfWeek());

    private static IEnumerable<ZonedDateTime> GetWeekNoVariantsExpanded(IEnumerable<ZonedDateTime> dates, RecurrencePattern pattern)
    {
        var weekYearRule = GetWeekYearRule(pattern);

        foreach ((var t, var weekNo) in dates.SelectMany(t => GetByWeekNoForYearNormalized(pattern, t.Year), (t, weekNo) => (t, weekNo)))
        {
            var date = t.LocalDateTime;

            // Make sure we start from a reference date that is in a week that belongs to the current year.
            // Its not important that the date lies in a certain week, but that the week belongs to the
            // current year and that the week day is preserved.
            if (date.Month == 1)
                date = date.PlusDays(7);
            else if (date.Month >= 12)
                date = date.PlusDays(-7);

            // Determine our current week number
            var currWeekNo = weekYearRule.GetWeekOfWeekYear(date.Date);

            // Move ahead to the correct week of the year
            date = date.PlusDays((weekNo - currWeekNo) * 7);

            // Ignore the week if it doesn't belong to the current year.
            if (weekYearRule.GetWeekYear(date.Date) != t.Year)
                continue;

            // Step backward single days until we're at the correct DayOfWeek
            date = GetFirstDayOfWeekDate(date, pattern.FirstDayOfWeek);

            foreach (var d in Enumerable.Range(0, 7).Select(i => date.PlusDays(i)))
                yield return d.InZoneLeniently(t.Zone);
        }
    }

    private static LocalDateTime GetFirstDayOfWeekDate(LocalDateTime date, DayOfWeek firstDayOfWeek)
    {
        var first = firstDayOfWeek.ToIsoDayOfWeek();
        if (date.DayOfWeek == first)
        {
            return date;
        }

        return date.Previous(first);
    }

    /// <summary>
    /// Normalize the BYWEEKNO values to be positive integers.
    /// </summary>
    private static List<int> GetByWeekNoForYearNormalized(RecurrencePattern pattern, int year)
    {
        var weeksInYear = new Lazy<int>(() => GetWeekYearRule(pattern).GetWeeksInWeekYear(year));
        return pattern.ByWeekNo
            .Select(weekNo => weekNo >= 0 ? weekNo : weeksInYear.Value + weekNo + 1)
            .OrderBy(x => x)
            .ToList();
    }

    /// <summary>
    /// Applies BYYEARDAY rules specified in this Recur instance to the specified date list. 
    /// If no BYYEARDAY rules are specified, the date list is returned unmodified.
    /// </summary>
    /// <param name="dates">The list of dates to which the BYYEARDAY rules will be applied.</param>
    /// <returns>The modified list of dates after applying the BYYEARDAY rules.</returns>
    private static IEnumerable<ZonedDateTime> GetYearDayVariants(IEnumerable<ZonedDateTime> dates, RecurrencePattern pattern, bool? expand, ref ExpandContext expandContext)
    {
        if (expand is null || pattern.ByYearDay.Count == 0)
            return dates;

        if ((expand == true) && !expandContext.DatesFullyExpanded)
        {
            expandContext.DatesFullyExpanded = true;
            return GetYearDayVariantsExpanded(dates, pattern);
        }

        // Limit behavior
        return GetYearDayVariantsLimited(dates, pattern);
    }

    private static IEnumerable<ZonedDateTime> GetYearDayVariantsExpanded(IEnumerable<ZonedDateTime> dates, RecurrencePattern pattern)
    {
        foreach (var date in dates)
        {
            var date1 = date.LocalDateTime;
            var yearDayDates = new SortedSet<LocalDateTime>(
                pattern.ByYearDay.Select(yearDay => yearDay > 0
                ? date1.PlusDays(-date1.DayOfYear + yearDay)
                : date1.PlusDays(-date1.DayOfYear + 1).PlusYears(1).PlusDays(yearDay))
                // Ignore the BY values that don't fit into the current year (i.e. +-366 in non-leap-years).
                .Where(d => d.Year == date1.Year));

            foreach (var d in yearDayDates)
                yield return d.InZoneLeniently(date.Zone);
        }
    }

    private static IEnumerable<ZonedDateTime> GetYearDayVariantsLimited(IEnumerable<ZonedDateTime> dates, RecurrencePattern pattern)
    {
        foreach (var zonedDate in dates)
        {
            var date = zonedDate.LocalDateTime;
            var candidates =
                from yearDay in pattern.ByYearDay
                let newDate = yearDay > 0
                    ? date.PlusDays(-date.DayOfYear + yearDay)
                    : date.PlusDays(-date.DayOfYear + 1).PlusYears(1).PlusDays(yearDay)
                select newDate;

            if (candidates.Contains(date))
                yield return date.InZoneLeniently(zonedDate.Zone);
        }
    }

    /// <summary>
    /// Applies BYMONTHDAY rules specified in this Recur instance to the specified date list. 
    /// If no BYMONTHDAY rules are specified, the date list is returned unmodified.
    /// </summary>
    /// <param name="dates">The list of dates to which the BYMONTHDAY rules will be applied.</param>
    /// <returns>The modified list of dates after applying the BYMONTHDAY rules.</returns>
    private static IEnumerable<ZonedDateTime> GetMonthDayVariants(IEnumerable<ZonedDateTime> dates, RecurrencePattern pattern, bool? expand, ref ExpandContext expandContext)
    {
        if (expand == null || pattern.ByMonthDay.Count == 0)
            return dates;

        if (expand.Value && !expandContext.DatesFullyExpanded)
        {
            expandContext.DatesFullyExpanded = true;
            return GetMonthDayVariantsExpanded(dates, pattern);
        }

        // limit behavior
        return GetMonthDayVariantsLimited(dates, pattern);
    }

    private static IEnumerable<ZonedDateTime> GetMonthDayVariantsLimited(IEnumerable<ZonedDateTime> dates, RecurrencePattern pattern)
    {
        foreach (var date in dates)
        {
            var daysInMonth = CalendarSystem.Iso.GetDaysInMonth(date.Year, date.Month);
            foreach (var monthDay in pattern.ByMonthDay)
            {
                var byMonthDay = (monthDay > 0) ? monthDay : (daysInMonth + monthDay + 1);
                if (date.Day == byMonthDay)
                {
                    yield return date;
                    break;
                }
            }
        }
    }

    private static IEnumerable<ZonedDateTime> GetMonthDayVariantsExpanded(IEnumerable<ZonedDateTime> dates, RecurrencePattern pattern)
    {
        foreach (var zonedDate in dates)
        {
            var date = zonedDate.LocalDateTime;
            var monthDayDates = new SortedSet<LocalDateTime>(
                from monthDay in pattern.ByMonthDay
                let daysInMonth = CalendarSystem.Iso.GetDaysInMonth(date.Year, date.Month)
                let monthDayAbs = (monthDay > 0) ? monthDay : (daysInMonth + monthDay + 1)
                where (monthDayAbs > 0) && (monthDayAbs <= daysInMonth)
                select date.PlusDays(-date.Day + monthDayAbs));

            foreach (var d in monthDayDates)
                yield return d.InZoneLeniently(zonedDate.Zone);
        }
    }

    /// <summary>
    /// Applies BYDAY rules specified in this Recur instance to the specified date list. 
    /// If no BYDAY rules are specified, the date list is returned unmodified.
    /// </summary>
    /// <param name="dates">The list of dates to which BYDAY rules will be applied.</param>
    /// <returns>The modified list of dates after applying BYDAY rules, or the original list if no BYDAY rules are specified.</returns>
    private static IEnumerable<ZonedDateTime> GetDayVariants(IEnumerable<ZonedDateTime> dates, RecurrencePattern pattern, bool? expand, ref ExpandContext expandContext)
    {
        if (expand == null || pattern.ByDay.Count == 0)
            return dates;

        if (expand.Value && !expandContext.DatesFullyExpanded)
        {
            // Expand behavior
            expandContext.DatesFullyExpanded = true;
            return GetDayVariantsExpanded(dates, pattern);
        }

        // Limit behavior
        return GetDayVariantsLimited(dates, pattern);
    }

    private static IEnumerable<ZonedDateTime> GetDayVariantsLimited(IEnumerable<ZonedDateTime> dates, RecurrencePattern pattern)
        =>
        // If no offset is specified, simply test the day of week!
        // FIXME: test with offset...
        dates.Where(date => pattern.ByDay.Any(weekDay => weekDay.DayOfWeek.Equals(date.DayOfWeek.ToDayOfWeek())));

    private static IEnumerable<ZonedDateTime> GetDayVariantsExpanded(IEnumerable<ZonedDateTime> dates, RecurrencePattern pattern)
    {
        foreach (var date in dates)
        {
            var weekDayDates = new SortedSet<LocalDateTime>();
            foreach (var day in pattern.ByDay)
                foreach (var d in GetAbsWeekDays(date.LocalDateTime, day, pattern))
                    weekDayDates.Add(d);

            foreach (var d in weekDayDates)
                yield return d.InZoneLeniently(date.Zone);
        }
    }

    /// <summary>
    /// Returns a list of applicable dates corresponding to the specified week day in accordance with the frequency
    /// specified by this recurrence rule.
    /// </summary>
    /// <param name="date">The date to start the evaluation from.</param>
    /// <param name="weekDay">The week day to evaluate.</param>
    /// <returns>A list of applicable dates.</returns>
    private static IEnumerable<LocalDateTime> GetAbsWeekDays(LocalDateTime date, WeekDay weekDay, RecurrencePattern pattern)
    {
        var dates = pattern switch
        {
            { Frequency: FrequencyType.Daily } => GetAbsWeekDaysDaily(date, weekDay),
            { Frequency: FrequencyType.Weekly } or { ByWeekNo: { Count: > 0 } } => GetAbsWeekDaysWeekly(date, pattern, weekDay),
            { Frequency: FrequencyType.Monthly } or { ByMonth: { Count: > 0 } } => GetAbsWeekDaysMonthly(date, pattern, weekDay),
            { Frequency: FrequencyType.Yearly } => GetAbsWeekDaysYearly(date, weekDay),
            _ => []
        };

        return GetOffsetDates(dates, weekDay.Offset);
    }

    private static IEnumerable<LocalDateTime> GetAbsWeekDaysDaily(LocalDateTime date, WeekDay weekDay)
        => (date.DayOfWeek.ToDayOfWeek() == weekDay.DayOfWeek) ? [date] : [];

    private static IEnumerable<LocalDateTime> GetAbsWeekDaysYearly(LocalDateTime date, WeekDay weekDay)
    {
        var year = date.Year;

        // construct a list of possible year days..
        date = date.PlusDays(-date.DayOfYear + 1);
        while (date.DayOfWeek.ToDayOfWeek() != weekDay.DayOfWeek)
        {
            date = date.PlusDays(1);
        }

        while (date.Year == year)
        {
            yield return date;
            date = date.PlusDays(7);
        }
    }

    private static IEnumerable<LocalDateTime> GetAbsWeekDaysMonthly(LocalDateTime date, RecurrencePattern pattern, WeekDay weekDay)
    {
        var month = date.Month;

        // construct a list of possible month days..
        date = date.PlusDays(-date.Day + 1);
        while (date.DayOfWeek.ToDayOfWeek() != weekDay.DayOfWeek)
        {
            date = date.PlusDays(1);
        }

        var weekYearRule = GetWeekYearRule(pattern);

        var byWeekNoNormalized = GetByWeekNoForYearNormalized(pattern, weekYearRule.GetWeekYear(date.Date));
        while (date.Month == month)
        {
            var currentWeekNo = weekYearRule.GetWeekOfWeekYear(date.Date);

            if ((byWeekNoNormalized.Count == 0 || byWeekNoNormalized.Contains(currentWeekNo))
                && (pattern.ByMonth.Count == 0 || pattern.ByMonth.Contains(date.Month)))
            {
                yield return date;
            }
            date = date.PlusDays(7);
        }
    }

    private static IEnumerable<LocalDateTime> GetAbsWeekDaysWeekly(LocalDateTime date, RecurrencePattern pattern, WeekDay weekDay)
    {
        var weekYearRule = GetWeekYearRule(pattern);

        var weekNo = weekYearRule.GetWeekOfWeekYear(date.Date);

        // Go to the first day of the week
        date = date.PlusDays(-GetWeekDayOffset(date, pattern.FirstDayOfWeek));

        // construct a list of possible week days..
        while (date.DayOfWeek.ToDayOfWeek() != weekDay.DayOfWeek)
        {
            date = date.PlusDays(1);
        }

        var nextWeekNo = weekYearRule.GetWeekOfWeekYear(date.Date);
        var currentWeekNo = weekYearRule.GetWeekOfWeekYear(date.Date);
        var byWeekNoNormalized = GetByWeekNoForYearNormalized(pattern, weekYearRule.GetWeekYear(date.Date));

        //When we manage weekly recurring pattern and we have boundary case:
        //Weekdays: Dec 31, Jan 1, Feb 1, Mar 1, Apr 1, May 1, June 1, Dec 31 - It's the 53th week of the year, but all another are 1st week number.
        while (currentWeekNo == weekNo || (nextWeekNo < weekNo && currentWeekNo == nextWeekNo && pattern.Frequency == FrequencyType.Weekly))
        {
            if ((byWeekNoNormalized.Count == 0 || byWeekNoNormalized.Contains(currentWeekNo))
                && (pattern.ByMonth.Count == 0 || pattern.ByMonth.Contains(date.Month)))
            {
                yield return date;
            }

            date = date.PlusDays(7);
            currentWeekNo = weekYearRule.GetWeekOfWeekYear(date.Date);
        }
    }

    /// <summary>
    /// Returns the days since the start of the week, 0 if the date is on the first day of the week.
    /// </summary>
    private static int GetWeekDayOffset(LocalDateTime date, DayOfWeek startOfWeek)
        => date.DayOfWeek.ToDayOfWeek() + ((date.DayOfWeek.ToDayOfWeek() < startOfWeek) ? 7 : 0) - startOfWeek;

    /// <summary>
    /// Returns a single-element sublist containing the element of <paramref name="dates"/> at <paramref name="offset"/>. 
    /// Valid offsets are from 1 to the size of the list. If an invalid offset is supplied, all elements from <paramref name="dates"/>
    /// are added to result.
    /// </summary>
    /// <param name="dates">The list from which to extract the element.</param>
    /// <param name="offset">The position of the element to extract.</param>
    private static IEnumerable<LocalDateTime> GetOffsetDates(IEnumerable<LocalDateTime> dates, int? offset)
    {
        if (offset is null)
            return dates;

        if (offset == 0)
            throw new EvaluationException("Encountered a day offset of 0 which is not allowed.");

        if (offset < 0) {
            offset = -offset;
            dates = dates.Reverse();
        }

        return dates.Skip(offset.Value - 1).Take(1);
    }

    /// <summary>
    /// Applies BYHOUR rules specified in this Recur instance to the specified date list. 
    /// If no BYHOUR rules are specified, the date list is returned unmodified.
    /// </summary>
    /// <param name="dates">The list of dates to which the BYHOUR rules will be applied.</param>
    /// <param name="pattern"></param>
    /// <param name="expand"></param>
    /// <returns>The modified list of dates after applying the BYHOUR rules.</returns>
    private static IEnumerable<ZonedDateTime> GetHourVariants(IEnumerable<ZonedDateTime> dates, RecurrencePattern pattern, bool? expand)
    {
        if (expand == null || pattern.ByHour.Count == 0)
            return dates;

        if (expand.Value)
        {
            // Expand behavior
            return dates.SelectMany(date => pattern.ByHour.Select(hour => date
                .LocalDateTime
                .With(x => new LocalTime(hour, x.Minute, x.Second))
                .InZone(date.Zone, ResolveFrom(date))));
        }

        // Limit behavior
        return dates.Where(date => pattern.ByHour.Contains(date.Hour));
    }

    /// <summary>
    /// Applies BYMINUTE rules specified in this Recur instance to the specified date list. 
    /// If no BYMINUTE rules are specified, the date list is returned unmodified.
    /// </summary>
    /// <param name="dates">The list of dates to which the BYMINUTE rules will be applied.</param>
    /// <param name="pattern"></param>
    /// <param name="expand"></param>
    /// <returns>The modified list of dates after applying the BYMINUTE rules.</returns>
    private static IEnumerable<ZonedDateTime> GetMinuteVariants(
        IEnumerable<ZonedDateTime> dates,
        RecurrencePattern pattern,
        bool? expand)
    {
        if (expand == null || pattern.ByMinute.Count == 0)
            return dates;

        if (expand.Value)
        {
            // Expand behavior
            return dates.SelectMany(date => pattern.ByMinute.Select(minute => date
                .LocalDateTime
                .With(x => new LocalTime(x.Hour, minute, x.Second))
                .InZone(date.Zone, ResolveFrom(date))));
        }

        // Limit behavior
        return dates.Where(date => pattern.ByMinute.Contains(date.Minute));
    }

    /// <summary>
    /// Applies BYSECOND rules specified in this Recur instance to the specified date list. 
    /// If no BYSECOND rules are specified, the date list is returned unmodified.
    /// </summary>
    /// <param name="dates">The list of dates to which the BYSECOND rules will be applied.</param>
    /// <param name="pattern"></param>
    /// <param name="expand"></param>
    /// <returns>The modified list of dates after applying the BYSECOND rules.</returns>
    private static IEnumerable<ZonedDateTime> GetSecondVariants(IEnumerable<ZonedDateTime> dates, RecurrencePattern pattern, bool? expand)
    {
        if (expand == null || pattern.BySecond.Count == 0)
            return dates;

        if (expand.Value)
        {
            // Expand behavior
            return dates.SelectMany(date => pattern.BySecond.Select(second => date
                .LocalDateTime
                .With(x => new LocalTime(x.Hour, x.Minute, second))
                .InZone(date.Zone, ResolveFrom(date))));
        }

        // Limit behavior
        return dates.Where(date => pattern.BySecond.Contains(date.Second));
    }

    /// <summary>
    /// Evaluate the occurrences of this recurrence pattern.
    /// </summary>
    /// <param name="referenceDate">The reference date, i.e. DTSTART.</param>
    /// <param name="periodStart">Start (incl.) of the period occurrences are generated for.</param>
    /// <param name="options"></param>
    /// <returns></returns>
    public override IEnumerable<EvaluationPeriod> Evaluate(CalDateTime referenceDate, DateTimeZone timeZone, Instant? periodStart, EvaluationOptions? options)
    {
        if (Pattern.Frequency < FrequencyType.Daily && !referenceDate.HasTime)
        {
            // This case is not defined by RFC 5545. We handle it by evaluating the rule
            // as if referenceDate had a time (i.e. set to midnight).
            referenceDate = new CalDateTime(referenceDate.Date, new TimeOnly(), referenceDate.TzId);
        }

        // Create a recurrence pattern suitable for use during evaluation.
        var pattern = ProcessRecurrencePattern(referenceDate);

        var periodQuery = GetDates(referenceDate, timeZone, periodStart, pattern, options)
            .Select(dt => new EvaluationPeriod(dt));

        if (pattern.Until is not null)
        {
            var until = pattern.Until.ToZonedDateTime(timeZone).ToInstant();

            periodQuery = periodQuery.TakeWhile(p => p.Start.ToInstant() <= until);
        }

        return periodQuery;
    }
}
